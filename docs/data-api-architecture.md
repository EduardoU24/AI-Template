# OpenDND Framework: Data & Service Architecture

This document serves as the "Long-Term Memory" and architectural manifest for the OpenDND Framework. It defines the standards for data management, service orchestration, and UI interaction.

## 1. Core Philosophy: Why this way?

Traditional React applications often suffer from "Prop Drilling" or "Context Bloat," where data fetching is tightly coupled to the UI. The OpenDND Framework solves this through a **Service-Driven Strategy Architecture**.

### The Goals
- **Backend Agnosticism**: Switch from a Mock/Memory DB to a live Strapi/REST/GraphQL API in seconds.
- **Developer Speed (DX)**: Start building the UI before the backend even exists.
- **AI-Ready Logic**: The structured nature of services makes it easy for AI models (like Gemini) to understand and generate new features.
- **Predictable Side Effects**: All business logic lives in `/service`, never in `page.tsx`.

---

## 2. Layered Responsibility

### A. The Manifest Layer (`/data`)
Static definitions. No logic allowed here.
- **Interfaces**: Define the shape of your domain objects.
- **Mock Data**: Exported as `DATA` constants to seed the memory strategy.
- **Enums/Flags**: Use bitwise flags (e.g., `1 << 0`) for complex permissions.

### B. The Logic Layer (`/service`)
The "Brain" of the application.
- **Provider Strategy**: Implements the `IDataProvider` interface.
- **Service Factories**: Uses `createService` to generate CRUD methods automatically.
- **Domain logic**: Custom business rules (e.g., `getUnreadCount()`) are added here.

### C. The UI Layer (`/app`)
Purely representational.
- **Consumption**: Components call `UserService.findAll()` or `UserNotificationService.markAllAsRead()`.
- **State**: React state or Context is only used for UI-specific flags (isOpen, isLoading).

---

## 3. The Strategy Pattern & Seeding

We use a **Deferred Seeding Mechanism** to ensure the app never crashes due to initialization race conditions.

### Memory Strategy (Default)
Ideal for prototyping. It stores data in a local JavaScript registry.
- **Supports**: Latency simulation, error simulation, and persistent-session seeding.

### Strapi / REST Strategy
Used for production. It maps collection names directly to REST endpoints.
- **Convention**: `service/user-posts.ts` -> `api/user-posts`.
- **Flattening**: Automatically handles Strapi's `{ data: { attributes } }` wrapping to keep UI code clean.

---

## 4. Code Etiquette & Best Practices

1.  **Thou Shalt Not Fetch in Components**: Never use `fetch()` or `axios` inside a `useEffect`. Always call a `Service`.
2.  **Naming is Destiny**: If your service file is `product-orders.ts`, your collection name **must** be `product-orders`. This ensures REST route compatibility.
3.  **Isolation via Scoping**: Use `createUserScopedService` for data that belongs to a specific user (filters by `userId` automatically).
4.  **Immutable Data**: Treat all data returned from services as immutable. Use service methods for updates.
5.  **Graceful Errors**: Always assume the API might fail. Use the `IApiResponse<T>` wrapper to check for `res.error`.

---

## 5. Adding a New Domain (The Checklist)

To add a new feature (e.g., "Project Tasks"):

1.  **Define Data**: Create `data/project-tasks.ts` with an interface and `DATA` mock array.
2.  **Create Service**: Create `service/project-tasks.ts`.
    ```typescript
    import { DATA, ITask } from '../data/project-tasks.ts';
    import { createService, registerInitialData } from './index.ts';

    const COLLECTION = 'project-tasks';
    registerInitialData(COLLECTION, DATA);
    export const ProjectTaskService = createService<ITask>(COLLECTION);
    ```
3.  **Bootstrap**: Use `ProjectTaskService` in your React components.

---

## 6. AI Orchestration (`/lib/ai.ts`)

The framework integrates Gemini AI to provide intelligent insights.
- **Placement**: AI logic lives in `lib/ai.ts`.
- **Context Injection**: Services pass data to AI functions to generate context-aware suggestions.
- **Example Flow**:
    - Component triggers `StatCard.onGenerateInsight`.
    - Service provides the current metric value.
    - `lib/ai.ts` queries Gemini and returns a string.
    - UI renders the insight with a "Generated by AI" badge.

## 7. Configuration (`/config/service.ts`)

This is the **Master Switch**. Changing `activeStrategy` here re-wires the entire application's data backbone.

```typescript
export const APP_CONFIG = {
  activeStrategy: 'memory', // Change to 'strapi' for production
  strapi: { ... }
};
```

---
*OpenDND Framework v2.0 - Developed for Scalability and Speed.*